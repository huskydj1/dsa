# Introduction to Graphs

![Real Network to Graph Representation Visual](images/Road%20Network.webp)
*A graph is a way of modelling the connections between different things. For example, if you look above, you can see [how a real road network might be modelled by a graph](https://transportgeography.org/contents/methods/graph-theory-definition-properties/graph-representation-real-network/), by converting the buildings to nodes and streets and edges.*

Graphs are collections of things, called nodes, and their connections, called edges. These structures are used to [model many real-life objects and their links](https://www.tutorialspoint.com/graph_theory/graph_theory_introduction.htm), including road networks (e.g. at Andover, dorms might be nodes and the streets between them might be edges), social networks (e.g. on Instagram, users would be nodes and friends would have an edge between them), and image captioning (e.g. nodes would be each object and edges would be their causal relationships). 

There are two qualifiers of graphs which are important to know. These are not mutually exclusive: an edge can be weighted and directed, or weighted and undirected, or unweighted and directed, or unweighted and undirected. 

![Weighted vs Unweighted Edge Visual](images/Weighted%20Edge.svg)
1) Weighted/Unweighted: The edge between two nodes may have a weight, depending on the specific application. Weights are numbers which capture [an essential quality of the connection between two nodes](https://www.ebi.ac.uk/training/online/courses/network-analysis-of-protein-interaction-data-an-introduction/introduction-to-graph-theory/graph-theory-graph-types-and-edge-properties/). For example, the edges in road networks are often weighted with the distance between the two locations. On the otherhand, the edges in social networks are often unweighted, so that User A following User B is qualitatively equivalent to User C following User D. 

![Directed vs Undirected Edge Visual](images/Direct%20Edge.svg)
2) Directed/Undirected: The edge between two nodes can also be directed. For example, the edges in social networks are often directed, since User A following User B does not guarantee the other direction. On the otherhand, the edges in roadmaps are often undirected, since not all streets are both ways. 

## Representation of Graphs

More concretely, graphs can be represented in code using an adjacency matrix and an adjacency list. For the above examples, I'll use the following graph, generated by [Graph Editor](https://csacademy.com/app/graph_editor/). 

![Example Graph, with four nodes, and edges 2 to 1, 2 to 4, 1 to 4, and 1 to 3](images/Graph%20Example.png)

### Adjacency Matrix

[An adjacency matrix is an $n \times n$ array](https://www.javatpoint.com/what-is-an-adjacency-matrix), wherein the value of ```a[i][j]```, for any node indices $i$ and $j$, contains their edge information. If the graph is unweighted, ```a[i][j]``` usually holds a boolean representing whether or not an edge exists. Otherwise, if the graph is weighted, ```a[i][j]``` equals the edge's weight, usually of int type. Please note that if the graph is undirected, ```a[i][j]``` is always equal to ```a[j][i]```, since both directions refer to the same edge. 

For example, the above graph would be represented as below:

|       | **1** | **2** | **3** | **4** |
|-------|-------|-------|-------|-------|
| **1** | 0     | 0     | 1     | 1     |
| **2** | 1     | 0     | 0     | 1     |
| **3** | 0     | 0     | 0     | 1     |
| **4** | 0     | 0     | 0     | 0     |

Adjacency matrices require $O(N^2)$ memory which can sometimes be impractical. Thus, unless graphs are dense and require $O(N^2)$ memory regardless, they are usually represented by adjacency lists instead. 

### Adjacency List

[An adjacency list is $n$ dimensional list of lists](https://www.programiz.com/dsa/graph-adjacency-list), where list $i$ contains a list of node $i's$ edges. For example, in the below example, node 1 is associated with 3 and 4, since the outward edges from 1 go to 3 and 4. 

| _Node_ | _Outward Edges_ |
|--------|-----------------|
| **1**  | 3, 4            |
| **2**  | 1, 4            |
| **3**  | 4               |
| **4**  |                 |

Adjacency lists require $O(E)$ memory. However, a downside is that querying edge information in a vanilla adjacency list requires $O(N)$, as worst case scenario you have to search through all of a node's edges until you find the one you are looking for. 


## Practice Problem

For practice, we suggest that readers implement the two different data structures for storing graphs. 

More formally, please write a function which initializes the data structure. Then, please implement the appropriate operations to represent the above graph with the data-structure. 
1. Adjacency Matrix

<details>
<summary>Click here for the solution: </summary>

Java:
```
```

Python:
```
```

</details>

2. Adjacency List

<details>
<summary>Click here for the solution: </summary>

Java:
```
```

Python:
```
```

</details>