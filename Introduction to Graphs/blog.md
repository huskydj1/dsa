# Introduction to Graphs

![Real Network to Graph Representation Visual](images/Road%20Network.webp)
*A graph is a way of modelling the connections between different things. For example, if you look above, you can see [how a real road network might be modelled by a graph](https://transportgeography.org/contents/methods/graph-theory-definition-properties/graph-representation-real-network/), by converting the buildings to nodes and streets and edges.*

Graphs are collections of things, called nodes, and their connections, called edges. These structures are used to [model many real-life objects and their links](https://www.tutorialspoint.com/graph_theory/graph_theory_introduction.htm), including road networks (e.g. at Andover, dorms might be nodes and the streets between them might be edges), social networks (e.g. on Instagram, users would be nodes and friends would have an edge between them), and image captioning (e.g. nodes would be each object and edges would be their causal relationships). 

There are two qualifiers of graphs which are important to know. These are not mutually exclusive: an edge can be weighted and directed, or weighted and undirected, or unweighted and directed, or unweighted and undirected. 

![Weighted vs Unweighted Edge Visual](images/Weighted%20Edge.svg)
1) Weighted/Unweighted: The edge between two nodes may have a weight, depending on the specific application. Weights are numbers which capture [an essential quality of the connection between two nodes](https://www.ebi.ac.uk/training/online/courses/network-analysis-of-protein-interaction-data-an-introduction/introduction-to-graph-theory/graph-theory-graph-types-and-edge-properties/). For example, the edges in road networks are often weighted with the distance between the two locations. On the otherhand, the edges in social networks are often unweighted, so that User A following User B is qualitatively equivalent to User C following User D. 

![Directed vs Undirected Edge Visual](images/Direct%20Edge.svg)
2) Directed/Undirected: The edge between two nodes can also be directed. For example, the edges in social networks are often directed, since User A following User B does not guarantee the other direction. On the otherhand, the edges in roadmaps are often undirected, since not all streets are both ways. 

**Exercises**
Question - Explain how all graphs can generalize to directed, weighted graphs. 
Answer - Unweighted edges are equivalent to having the same weight on all edges, and undirected edges are equivalent to directed edges in both directions. 

## Representation of Graphs

More concretely, graphs can be represented in code using an adjacency matrix and an adjacency list. For the above examples, I'll use the following graph, generated by [Graph Editor](https://csacademy.com/app/graph_editor/). 

![Example Graph, with four nodes, and edges 2 to 1, 2 to 4, 1 to 4, and 1 to 3](images/Graph%20Example.png)

### Adjacency Matrix

[An adjacency matrix is an $n \times n$ array](https://www.javatpoint.com/what-is-an-adjacency-matrix), wherein the value of ```a[i][j]```, for any node indices $i$ and $j$, contains their edge information. If the graph is unweighted, ```a[i][j]``` usually holds a boolean representing whether or not an edge exists. Otherwise, if the graph is weighted, ```a[i][j]``` equals the edge's weight, usually of int type. Please note that if the graph is undirected, ```a[i][j]``` is always equal to ```a[j][i]```, since both directions refer to the same edge. 

For example, the above graph would be represented as below:

|       | **0** | **1** | **2** | **3** |
|-------|-------|-------|-------|-------|
| **0** | 0     | 0     | 1     | 1     |
| **1** | 1     | 0     | 0     | 1     |
| **2** | 0     | 0     | 0     | 1     |
| **3** | 0     | 0     | 0     | 0     |

Adjacency matrices require $O(N^2)$ memory which can sometimes be impractical. Thus, unless graphs are dense and require $O(N^2)$ memory regardless, they are usually represented by adjacency lists instead. 

### Adjacency List

[An adjacency list is $n$ dimensional list of lists](https://www.programiz.com/dsa/graph-adjacency-list), where list $i$ contains a list of node $i's$ edges. For example, in the below example, node 1 is associated with 3 and 4, since the outward edges from 1 go to 3 and 4. 

| _Node_ | _Outward Edges_ |
|--------|-----------------|
| **0**  | 2, 3            |
| **1**  | 0, 3            |
| **2**  | 3               |
| **3**  |                 |

Adjacency lists require $O(E)$ memory. However, a downside is that querying edge information in a vanilla adjacency list requires $O(N)$, as worst case scenario you have to search through all of a node's edges until you find the one you are looking for. 

**Exercises**
Question - Suppose we create a graph representing marriages, where people are represented as nodes and an edge connects them if they are married. Should you represent this graph using an adjacency matrix or an adjacency list?  
Answer - This is a sparse network, or a network where the number of nodes is roughly equal to the number of edges, because the vast majority of people will have one or zero outgoing edges. Thus, this should be represented as an adjacency list, to avoid allocating an unnecessarily large array in your memory. 

****

## Practice Problem

For practice, we suggest that readers implement the two different data structures for storing graphs. 

More formally, please write a function which initializes each data structure. Then, please implement the appropriate operations to represent the above graph with the data-structure. 
1. Adjacency Matrix
2. Adjacency List

<details>
<summary>Click here for the solution: </summary>

Java:
```
import java.io.*;
import java.util.*;

class AdjacencyMatrix{
    // An Adjacency Matrix for storing directed, unweighted graphs
    int n;
    boolean[][] arr;

    public AdjacencyMatrix(int numberNodes){
        // Creates a new instance for n nodes, indexed 0
        this.arr = new boolean[numberNodes][numberNodes];
        this.n = numberNodes;
    }

    public boolean getEdge(int u, int v){
        // Gets the edge between nodes u and v, if possible
        assert(u>=0 && u<this.n && v>=0 && v<this.n);

        return this.arr[u][v];
    }

    public void addEdge(int u, int v){
        // Adds an edge between nodes u and v, if possible
        assert(u>=0 && u<this.n && v>=0 && v<this.n);

        this.arr[u][v] = true;
    }

    public void removeEdge(int u, int v){
        // Removes the edge between nodes u and v, if possible
        assert(u>=0 && u<this.n && v>=0 && v<this.n);

        this.arr[u][v] = false;
    }

    public void printGraph(){
        // Prints graph, if possible
        assert(this.arr != null);

        for(int i = 0; i<this.arr.length; ++i){
            System.out.println(Arrays.toString(this.arr[i]));
        }
    }
}

class AdjacencyList{
    // An Adjacency List for storing directed, unweighted graphs
    int n;
    ArrayList<Integer>[] lst;

    public AdjacencyList(int numberNodes){
        // Creates a new instance for n nodes, indexed 0
        this.lst = new ArrayList[numberNodes];
        for(int i = 0; i<numberNodes; ++i){
            this.lst[i] = new ArrayList<Integer>();
        }
        this.n = numberNodes;
    }

    public boolean getEdge(int u, int v){
        // Gets the edge between nodes u and v, if possible
        assert(u>=0 && u<this.n && v>=0 && v<this.n);

        return this.lst[u].contains(v);
    }

    public void addEdge(int u, int v){
        // Adds an edge between nodes u and v, if possible
        assert(u>=0 && u<this.n && v>=0 && v<this.n);

        this.lst[u].add(v);
    }

    public void removeEdge(int u, int v){
        // Removes the edge between nodes u and v, if possible
        assert(u>=0 && u<this.n && v>=0 && v<this.n);

        this.lst[u].remove(Integer.valueOf(v));
    }

    public void printGraph(){
        // Prints graph, if possible
        for(int i = 0; i<this.n; ++i){
            assert(this.lst[i] != null);
            System.out.println(Integer.toString(i) + ": " + this.lst[i].toString());
        }
    }
}

public class IntroductionToGraphs {
    public static void main(String[] args) throws IOException{
        // Initialize Adjacency Matrix
        AdjacencyMatrix graphMat = new AdjacencyMatrix(4);

        // Add Edges
        graphMat.addEdge(0, 2);
        graphMat.addEdge(0, 3);
        graphMat.addEdge(1, 0);
        graphMat.addEdge(1, 3);
        graphMat.addEdge(2, 3);

        // Print Final Graph
        graphMat.printGraph();

        // Initialize Adjacency Matrix
        AdjacencyList graphList = new AdjacencyList(4);

        // Add Edges
        graphList.addEdge(0, 2);
        graphList.addEdge(0, 3);
        graphList.addEdge(1, 0);
        graphList.addEdge(1, 3);
        graphList.addEdge(2, 3);

        // Print Final Graph
        graphList.printGraph();
    }
}
```

Python:
```
class AdjacencyMatrix:
    # An Adjacency Matrix for storing directed, unweighted graphs
    n = 0
    arr = None

    def __init__(self, numberNodes):
        # Creates a new instance for n nodes, indexed 0
        self.arr = [[False]*numberNodes for i in range(numberNodes)]
        self.n = numberNodes

    def getEdge(self, u, v):
        # Gets the edge between nodes u and v, if possible
        assert(u>=0 and u<self.n and v>=0 and v<self.n)

        return self.arr[u][v]

    def addEdge(self, u, v):
        # Adds an edge between nodes u and v, if possible
        assert(u>=0 and u<self.n and v>=0 and v<self.n)

        self.arr[u][v] = True

    def removeEdge(self, u, v):
        # Removes the edge between nodes u and v, if possible
        assert(u>=0 and u<self.n and v>=0 and v<self.n)

        self.arr[u][v] = False

    def printGraph(self):
        # Prints graph, if possible
        assert(self.arr != None)

        for i in range(self.n):
            print(self.arr[i])

class AdjacencyList:
    # An Adjacency List for storing directed, unweighted graphs
    n = 0
    lst = None

    def __init__(self, numberNodes):
        # Creates a new instance for n nodes, indexed 0
        self.lst = [[] for i in range(numberNodes)]
        self.n = numberNodes

    def getEdge(self, u, v):
        # Gets the edge between nodes u and v, if possible
        assert(u>=0 and u<self.n and v>=0 and v<self.n)

        return v in self.lst[u]

    def addEdge(self, u, v):
        # Adds an edge between nodes u and v, if possible
        assert(u>=0 and u<self.n and v>=0 and v<self.n)

        self.lst[u].append(v)

    def removeEdge(self, u, v):
        # Removes the edge between nodes u and v, if possible
        assert(u>=0 and u<self.n and v>=0 and v<self.n)

        self.lst[u].remove(v)

    def printGraph(self):
        # Prints graph, if possible
        for i in range(self.n):
            assert(self.lst[i] != None)
            print(i,  ":", self.lst[i])

# Initialize Adjacency Matrix
graphMat = AdjacencyMatrix(4)

# Add Edges
graphMat.addEdge(0, 2)
graphMat.addEdge(0, 3)
graphMat.addEdge(1, 0)
graphMat.addEdge(1, 3)
graphMat.addEdge(2, 3)

# Print Final Graph
graphMat.printGraph()

# Initialize Adjacency Matrix
graphList = AdjacencyList(4)

# Add Edges
graphList.addEdge(0, 2)
graphList.addEdge(0, 3)
graphList.addEdge(1, 0)
graphList.addEdge(1, 3)
graphList.addEdge(2, 3)

# Print Final Graph
graphList.printGraph()

```

</details>